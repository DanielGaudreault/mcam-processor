<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate CNC Viewer (Haas & Okuma Genos)</title>
    <link rel="icon" type="image/png" href="images/main logo 2.png"> <!-- Updated Favicon -->
    <!-- For iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="images/icons/apple-touch-icon.png">
    <!-- For Android -->
    <link rel="manifest" href="manifest.json"> <!-- Manifest file for PWA -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            color: #333;
            background-color: #f5f5f5;
            overflow: hidden;
        }

        #viewer-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
        }

        #upload-button {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 8px 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #upload-button:hover {
            background: #357ab8;
        }

        #file-input {
            display: none; /* Hidden, triggered by button */
        }

        .toolbar {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 8px;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tool-button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
        }

        .tool-button:hover {
            background: #357ab8;
        }

        .tool-button.active {
            background: #357ab8;
        }

        #sidebar {
            width: 300px;
            height: 100%;
            background: #fff;
            padding: 10px;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            z-index: 100;
        }

        #sidebar h3 {
            margin: 0 0 10px;
            color: #4a90e2;
            font-size: 14px;
        }

        #gcode-input {
            width: 100%;
            height: 50%;
            resize: none;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
        }

        #info-panel {
            margin-top: 20px;
        }

        .info-item {
            font-size: 12px;
            margin-bottom: 5px;
        }

        .info-label {
            font-weight: bold;
            display: inline-block;
            width: 100px;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
        }

        #canvas-2d, #canvas-3d {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #canvas-2d {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="viewer-container">
        <button id="upload-button">Upload File</button>
        <input type="file" id="file-input" accept=".gcode,.mcam,.nc,.tap" />

        <div id="sidebar">
            <h3>G-Code Editor</h3>
            <textarea id="gcode-input" placeholder="Paste or edit G-code here (MCAM shows binary info)..."></textarea>
            <div id="info-panel">
                <h3>File Info</h3>
                <div class="info-item"><span class="info-label">File Name:</span><span id="file-name">None</span></div>
                <div class="info-item"><span class="info-label">File Size:</span><span id="file-size">0 KB</span></div>
                <div class="info-item"><span class="info-label">Toolpaths:</span><span id="toolpath-count">0</span></div>
                <div class="info-item"><span class="info-label">Bounds:</span><span id="bounds">N/A</span></div>
                <div class="info-item"><span class="info-label">Units:</span><span id="units">N/A</span></div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas-2d"></canvas>
            <canvas id="canvas-3d"></canvas>
        </div>

        <div class="toolbar">
            <button class="tool-button" id="view-toggle" data-tooltip="Toggle 2D/3D">2D/3D</button>
            <button class="tool-button" id="simulate" data-tooltip="Simulate Toolpath">Simulate</button>
            <button class="tool-button" id="reset-view" data-tooltip="Reset View">Reset</button>
            <button class="tool-button" id="toggle-material" data-tooltip="Show/Hide Material">Material</button>
        </div>

        <div id="loading-overlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div>Loading...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // MCAM Parser
        class McamParser {
            constructor(buffer) {
                this.buffer = buffer;
                this.dataView = new DataView(buffer);
                this.offset = 0;
                this.littleEndian = true;
                this.supportedVersions = [1, 2, 3];
            }

            parse() {
                try {
                    this.checkFileSize();
                    const header = this.parseHeader();
                    if (!this.supportedVersions.includes(header.version)) throw new Error(`Unsupported MCAM version ${header.version}`);
                    const geometry = this.parseGeometry(header.version);
                    const toolpaths = this.parseToolpaths(header.version);
                    return { success: true, header, geometry, toolpaths };
                } catch (error) {
                    return { success: false, error: error.message };
                }
            }

            checkFileSize() { if (this.buffer.byteLength < 16) throw new Error('File too small'); }
            parseHeader() {
                const magic = this.readString(4);
                if (!['MCAM', 'MMC2'].includes(magic)) throw new Error(`Invalid header: ${magic}`);
                const version = this.readUint32();
                const fileSize = this.readUint32();
                if (fileSize > this.buffer.byteLength) throw new Error('File size mismatch');
                return { version, fileSize, creationDate: this.readUint64(), units: this.readByte() === 0 ? 'mm' : 'inch' };
            }

            parseGeometry(version) {
                const vertexCount = this.readUint32();
                if (vertexCount > 1000000) throw new Error('Excessive vertex count');
                const vertices = new Float32Array(vertexCount * 3);
                for (let i = 0; i < vertexCount; i++) {
                    vertices[i * 3] = this.readFloat();
                    vertices[i * 3 + 1] = this.readFloat();
                    vertices[i * 3 + 2] = this.readFloat();
                }
                const faceCount = this.readUint32();
                if (faceCount > 2000000) throw new Error('Excessive face count');
                const faces = new Uint32Array(faceCount * 3);
                for (let i = 0; i < faceCount; i++) {
                    faces[i * 3] = this.readUint32();
                    faces[i * 3 + 1] = this.readUint32();
                    faces[i * 3 + 2] = this.readUint32();
                }
                return { vertices, faces };
            }

            parseToolpaths(version) {
                const pathCount = this.readUint16();
                const toolpaths = [];
                for (let i = 0; i < pathCount; i++) {
                    toolpaths.push({ toolNumber: this.readUint16(), points: this.readPathPoints() });
                }
                return toolpaths;
            }

            readPathPoints() {
                const pointCount = this.readUint32();
                const points = [];
                for (let i = 0; i < pointCount; i++) {
                    points.push({ 
                        x: this.readFloat(), 
                        y: this.readFloat(), 
                        z: this.readFloat(), 
                        feedRate: this.readFloat(),
                        a: 0 // Assuming A-axis isn't in MCAM, adjust if needed
                    });
                }
                return points;
            }

            readUint32() { const v = this.dataView.getUint32(this.offset, this.littleEndian); this.offset += 4; return v; }
            readUint16() { const v = this.dataView.getUint16(this.offset, this.littleEndian); this.offset += 2; return v; }
            readFloat() { const v = this.dataView.getFloat32(this.offset, this.littleEndian); this.offset += 4; return v; }
            readByte() { const v = this.dataView.getUint8(this.offset); this.offset += 1; return v; }
            readUint64() { const l = this.readUint32(); const r = this.readUint32(); return l + 2 ** 32 * r; }
            readString(length) {
                let result = '';
                for (let i = 0; i < length; i++) {
                    const char = this.readByte();
                    if (char !== 0) result += String.fromCharCode(char);
                }
                return result;
            }
        }

        // G-code Parser for Haas and Okuma Genos
        class GcodeParser {
            constructor(text) {
                this.text = text;
            }

            parse() {
                const lines = this.text.split('\n');
                const toolpaths = [];
                let currentTool = 0;
                let points = [];
                let lastPos = { x: 0, y: 0, z: 0, a: 0, feedRate: 0 };
                let units = 'mm';

                lines.forEach(line => {
                    line = line.trim().toUpperCase();
                    if (!line || line.startsWith(';') || line.startsWith('(')) return;
                    if (line.includes('G20')) units = 'inch';
                    if (line.includes('G21')) units = 'mm';
                    if (line.startsWith('T')) {
                        if (points.length) toolpaths.push({ toolNumber: currentTool, points });
                        points = [];
                        currentTool = parseInt(line.match(/T(\d+)/)?.[1]) || 0;
                    } else if (line.match(/G[0-1]/) || (line.includes('G254') || line.includes('G605'))) { // Haas DWO, Okuma DFO
                        const coords = line.match(/[XYZA][-\d.]+|F[\d.]+/g) || [];
                        const point = { ...lastPos };
                        coords.forEach(c => {
                            const value = parseFloat(c.substring(1));
                            if (c[0] === 'X') point.x = value;
                            if (c[0] === 'Y') point.y = value;
                            if (c[0] === 'Z') point.z = value;
                            if (c[0] === 'A') point.a = value; // 4-axis rotation
                            if (c[0] === 'F') point.feedRate = value;
                        });
                        points.push(point);
                        lastPos = { ...point };
                    }
                });

                if (points.length) toolpaths.push({ toolNumber: currentTool, points });
                return { success: true, toolpaths, units };
            }
        }

        // CNC Viewer Class
        class CNCViewer {
            constructor() {
                this.canvas2D = document.getElementById('canvas-2d');
                this.ctx2D = this.canvas2D.getContext('2d');
                this.scene = new THREE.Scene();
                this.camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer3D = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas-3d'), antialias: true });
                this.controls = new THREE.OrbitControls(this.camera3D, this.renderer3D.domElement);
                this.toolpaths = [];
                this.is2DView = false;
                this.showMaterial = true;
                this.materialMesh = null;
                this.animating = false;
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.ctx2D.strokeStyle = '#0000ff';
                this.ctx2D.lineWidth = 1;

                this.renderer3D.setSize(this.canvas2D.width, this.canvas2D.height);
                this.camera3D.position.set(50, 50, 50);
                this.camera3D.lookAt(0, 0, 0);
                this.controls.enableDamping = true;
                this.controls.target.set(0, 0, 0);
                this.scene.add(new THREE.AmbientLight(0x404040));
                const light = new THREE.DirectionalLight(0xffffff, 0.8);
                light.position.set(1, 1, 1);
                this.scene.add(light);

                const grid = new THREE.GridHelper(100, 100, 0x888888, 0x888888);
                grid.position.set(0, 0, -0.1);
                this.scene.add(grid);

                this.animate();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                this.canvas2D.width = container.clientWidth;
                this.canvas2D.height = container.clientHeight;
                this.renderer3D.setSize(container.clientWidth, container.clientHeight);
                this.camera3D.aspect = container.clientWidth / container.clientHeight;
                this.camera3D.updateProjectionMatrix();
            }

            loadToolpaths(toolpaths) {
                this.toolpaths = toolpaths;
                this.render2D();
                this.render3D();
                this.loadMaterial();
            }

            render2D() {
                this.ctx2D.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);
                const scale = Math.min(this.canvas2D.width, this.canvas2D.height) / 100;
                const offsetX = this.canvas2D.width / 2;
                const offsetY = this.canvas2D.height / 2;

                this.ctx2D.strokeStyle = '#888888';
                this.ctx2D.lineWidth = 0.5;
                for (let i = -50; i <= 50; i += 5) {
                    this.ctx2D.beginPath();
                    this.ctx2D.moveTo(i * scale + offsetX, -50 * scale + offsetY);
                    this.ctx2D.lineTo(i * scale + offsetX, 50 * scale + offsetY);
                    this.ctx2D.stroke();
                    this.ctx2D.beginPath();
                    this.ctx2D.moveTo(-50 * scale + offsetX, i * scale + offsetY);
                    this.ctx2D.lineTo(50 * scale + offsetX, i * scale + offsetY);
                    this.ctx2D.stroke();
                }

                this.ctx2D.strokeStyle = '#0000ff';
                this.ctx2D.lineWidth = 1;
                this.toolpaths.forEach(tp => {
                    this.ctx2D.beginPath();
                    tp.points.forEach((p, i) => {
                        const x = p.x * scale + offsetX;
                        const y = p.y * scale + offsetY;
                        if (i === 0) this.ctx2D.moveTo(x, y);
                        else this.ctx2D.lineTo(x, y);
                    });
                    this.ctx2D.stroke();
                });
            }

            render3D() {
                this.scene.children.filter(obj => obj.userData.isToolpath || obj === this.materialMesh).forEach(obj => this.scene.remove(obj));
                this.toolpaths.forEach(tp => {
                    const points = tp.points.map(p => {
                        const vec = new THREE.Vector3(p.x, p.y, p.z);
                        vec.applyAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(p.a || 0));
                        return vec;
                    });
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                    const line = new THREE.Line(geometry, material);
                    line.userData.isToolpath = true;
                    this.scene.add(line);
                });
            }

            loadMaterial() {
                if (this.materialMesh) this.scene.remove(this.materialMesh);
                if (!this.showMaterial || !this.toolpaths.length) return;

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                this.toolpaths.forEach(tp => {
                    tp.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        minZ = Math.min(minZ, p.z);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                        maxZ = Math.max(maxZ, p.z);
                    });
                });

                const width = Math.max(maxX - minX + 10, 50);
                const height = Math.max(maxY - minY + 10, 50);
                const depth = Math.max(maxZ - minZ + 10, 50);
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.7 });
                this.materialMesh = new THREE.Mesh(geometry, material);
                this.materialMesh.position.set((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2);
                this.scene.add(this.materialMesh);
            }

            toggleView() {
                this.is2DView = !this.is2DView;
                this.canvas2D.style.display = this.is2DView ? 'block' : 'none';
                this.canvas3D.style.display = this.is2DView ? 'none' : 'block';
                if (this.is2DView) this.render2D();
            }

            toggleMaterial() {
                this.showMaterial = !this.showMaterial;
                if (this.materialMesh) this.materialMesh.visible = this.showMaterial;
                if (this.showMaterial && !this.materialMesh) this.loadMaterial();
            }

            resetView() {
                if (this.is2DView) {
                    this.render2D();
                } else {
                    this.camera3D.position.set(50, 50, 50);
                    this.controls.target.set(0, 0, 0);
                    this.controls.update();
                }
            }

            startSimulation() {
                if (!this.toolpaths.length) return;
                this.animating = true;
                this.animationData = { currentPath: 0, currentPoint: 0, speed: 0.05 };
            }

            stopSimulation() {
                this.animating = false;
            }

            updateSimulation() {
                if (!this.animating) return;
                const { currentPath, currentPoint } = this.animationData;
                if (currentPath >= this.toolpaths.length) {
                    this.stopSimulation();
                    return;
                }

                const path = this.toolpaths[currentPath];
                const pointIndex = Math.floor(currentPoint);
                if (pointIndex >= path.points.length) {
                    this.animationData.currentPath++;
                    this.animationData.currentPoint = 0;
                    return;
                }

                const point = path.points[pointIndex];
                if (this.is2DView) {
                    this.render2D();
                    const scale = Math.min(this.canvas2D.width, this.canvas2D.height) / 100;
                    const offsetX = this.canvas2D.width / 2;
                    const offsetY = this.canvas2D.height / 2;
                    this.ctx2D.fillStyle = '#ff0000';
                    this.ctx2D.beginPath();
                    this.ctx2D.arc(point.x * scale + offsetX, point.y * scale + offsetY, 2, 0, 2 * Math.PI);
                    this.ctx2D.fill();
                } else {
                    const tool = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1, 3, 16),
                        new THREE.MeshBasicMaterial({ color: 0xff0000 })
                    );
                    tool.position.set(point.x, point.y, point.z);
                    tool.rotation.x = THREE.MathUtils.degToRad(point.a || 0) + Math.PI / 2;
                    tool.userData.isToolpath = true;
                    this.scene.add(tool);
                    setTimeout(() => this.scene.remove(tool), 100);
                }

                this.animationData.currentPoint += this.animationData.speed;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateSimulation();
                if (!this.is2DView) {
                    this.controls.update();
                    this.renderer3D.render(this.scene, this.camera3D);
                }
            }
        }

        // File Format Detection
        function detectFileFormat(buffer, fileName) {
            const header = new Uint8Array(buffer.slice(0, 4));
            const headerStr = String.fromCharCode(...header);
            const ext = fileName.split('.').pop().toLowerCase();

            if (headerStr === 'MCAM' || headerStr === 'MMC2') return 'MCAM';
            if (ext === 'gcode' || ext === 'nc' || ext === 'tap' || headerStr.startsWith('%') || new TextDecoder().decode(buffer).match(/G[0-1]/)) return 'GCODE';
            return 'UNKNOWN';
        }

        // Main Application
        document.addEventListener('DOMContentLoaded', () => {
            const viewer = new CNCViewer();
            const uploadButton = document.getElementById('upload-button');
            const fileInput = document.getElementById('file-input');
            const gcodeInput = document.getElementById('gcode-input');
            const viewToggleBtn = document.getElementById('view-toggle');
            const simulateBtn = document.getElementById('simulate');
            const resetViewBtn = document.getElementById('reset-view');
            const toggleMaterialBtn = document.getElementById('toggle-material');
            const loadingOverlay = document.getElementById('loading-overlay');

            function updateInfo(file, data) {
                document.getElementById('file-name').textContent = file ? file.name : 'None';
                document.getElementById('file-size').textContent = file ? `${(file.size / 1024).toFixed(2)} KB` : '0 KB';
                document.getElementById('toolpath-count').textContent = data.toolpaths.length;
                document.getElementById('units').textContent = data.units || data.header?.units || 'N/A';

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                data.toolpaths.forEach(tp => {
                    tp.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        minZ = Math.min(minZ, p.z);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                        maxZ = Math.max(maxZ, p.z);
                    });
                });
                document.getElementById('bounds').textContent = `X: ${minX.toFixed(1)}-${maxX.toFixed(1)}, Y: ${minY.toFixed(1)}-${maxY.toFixed(1)}, Z: ${minZ.toFixed(1)}-${maxZ.toFixed(1)}`;
            }

            function loadFile(file) {
                loadingOverlay.style.display = 'flex';
                const reader = new FileReader();

                reader.onload = () => {
                    const buffer = reader.result;
                    const format = detectFileFormat(buffer, file.name);

                    if (format === 'MCAM') {
                        const parser = new McamParser(buffer);
                        const data = parser.parse();
                        if (data.success) {
                            viewer.loadToolpaths(data.toolpaths);
                            updateInfo(file, data);
                            gcodeInput.value = 'Binary MCAM file - toolpaths only (not editable)';
                        } else {
                            alert(`MCAM parsing failed: ${data.error}`);
                        }
                    } else if (format === 'GCODE') {
                        const text = new TextDecoder().decode(buffer);
                        gcodeInput.value = text;
                        const parser = new GcodeParser(text);
                        const data = parser.parse();
                        if (data.success) {
                            viewer.loadToolpaths(data.toolpaths);
                            updateInfo(file, data);
                        } else {
                            alert('G-code parsing failed');
                        }
                    } else {
                        alert(`Unsupported file format: ${format}`);
                    }
                    loadingOverlay.style.display = 'none';
                };

                reader.readAsArrayBuffer(file); // Use ArrayBuffer for flexibility
            }

            uploadButton.addEventListener('click', () => {
                fileInput.click(); // Trigger hidden file input
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadFile(file);
            });

            gcodeInput.addEventListener('change', () => {
                const parser = new GcodeParser(gcodeInput.value);
                const data = parser.parse();
                if (data.success) {
                    viewer.loadToolpaths(data.toolpaths);
                    updateInfo(null, data);
                }
            });

            viewToggleBtn.addEventListener('click', () => {
                viewer.toggleView();
                viewToggleBtn.classList.toggle('active');
            });

            simulateBtn.addEventListener('click', () => {
                if (viewer.animating) {
                    viewer.stopSimulation();
                    simulateBtn.classList.remove('active');
                } else {
                    viewer.startSimulation();
                    simulateBtn.classList.add('active');
                }
            });

            resetViewBtn.addEventListener('click', () => viewer.resetView());

            toggleMaterialBtn.addEventListener('click', () => {
                viewer.toggleMaterial();
                toggleMaterialBtn.classList.toggle('active');
            });

            // Load sample G-code for Haas/Okuma
            const sampleGcode = `G21\nT1\nG0 X0 Y0 Z10 A0\nG1 X10 Y10 Z5 A90 F100\nG1 X20 Y20 Z0 A180\nG0 X0 Y0 Z10 A0`;
            gcodeInput.value = sampleGcode;
            const parser = new GcodeParser(sampleGcode);
            const data = parser.parse();
            viewer.loadToolpaths(data.toolpaths);
            updateInfo(null, data);
        });
    </script>
</body>
</html>
