<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate CNC Viewer (Haas & Okuma Genos)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            color: #333;
            background-color: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #viewer-container {
            flex: 1;
            display: flex;
            width: 100%;
            height: 100%;
        }

        #file-input {
            display: none;
        }

        .toolbar {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            align-items: flex-end;
        }

        .toolbar-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .tool-button, #upload-button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            position: relative;
        }

        .tool-button:hover, #upload-button:hover {
            background: #357ab8;
        }

        .tool-button.active {
            background: #357ab8;
        }

        .tool-button[data-tooltip]:hover:after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
        }

        #sidebar {
            width: 320px;
            min-width: 200px;
            height: 100%;
            background: #fff;
            padding: 15px;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        #sidebar h3 {
            margin: 0 0 10px;
            color: #4a90e2;
            font-size: 14px;
        }

        #gcode-input {
            width: 100%;
            height: 60%;
            resize: vertical;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            box-sizing: border-box;
            background: #fafafa;
        }

        #info-panel {
            margin-top: 20px;
        }

        .info-item {
            font-size: 12px;
            margin-bottom: 5px;
        }

        .info-label {
            font-weight: bold;
            display: inline-block;
            width: 100px;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas-2d, #canvas-3d {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #canvas-2d {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            #sidebar {
                width: 250px;
            }
            .toolbar {
                right: 5px;
                top: 5px;
                padding: 5px;
            }
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #fff;
            padding: 5px;
            border-radius: 4px;
        }

        #speed-slider {
            width: 100px;
        }

        #viewcube {
            background: #fff;
            padding: 5px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .viewcube-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .viewcube-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: #4a90e2;
            font-size: 12px;
        }

        .viewcube-btn:hover {
            color: #357ab8;
        }

        #vc-home {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: #4a90e2;
        }

        #vc-home:hover {
            color: #357ab8;
        }

        #vc-home svg {
            width: 16px;
            height: 16px;
        }

        #viewcube span {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }

        #viewcube canvas {
            border: 1px solid #ddd;
        }

        .control-icons {
            display: flex;
            gap: 5px;
            background: #fff;
            padding: 5px;
            border-radius: 4px;
            justify-content: flex-end;
        }

        .icon {
            cursor: pointer;
            padding: 5px;
            color: #4a90e2;
            transition: color 0.2s;
        }

        .icon:hover {
            color: #357ab8;
        }

        .icon svg {
            width: 16px;
            height: 16px;
        }

        .icon.active svg {
            color: #357ab8;
        }
    </style>
</head>
<body>
    <div id="viewer-container">
        <input type="file" id="file-input" accept=".gcode,.mcam,.nc,.tap" />

        <div id="sidebar">
            <h3>G-Code Editor</h3>
            <textarea id="gcode-input" placeholder="Paste or edit G-code here (MCAM may show limited data)..."></textarea>
            <div id="info-panel">
                <h3>File Info</h3>
                <div class="info-item"><span class="info-label">File Name:</span><span id="file-name">None</span></div>
                <div class="info-item"><span class="info-label">File Size:</span><span id="file-size">0 KB</span></div>
                <div class="info-item"><span class="info-label">Toolpaths:</span><span id="toolpath-count">0</span></div>
                <div class="info-item"><span class="info-label">Bounds:</span><span id="bounds">N/A</span></div>
                <div class="info-item"><span class="info-label">Units:</span><span id="units">N/A</span></div>
                <div class="info-item"><span class="info-label">Current Tool:</span><span id="current-tool">N/A</span></div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas-2d"></canvas>
            <canvas id="canvas-3d"></canvas>
        </div>

        <div class="toolbar">
            <div class="toolbar-buttons">
                <button id="upload-button">Upload File</button>
                <button class="tool-button" id="view-toggle" data-tooltip="Toggle 2D/3D">2D/3D</button>
                <div class="speed-control">
                    <label for="speed-slider" style="font-size: 12px;">Speed:</label>
                    <input type="range" id="speed-slider" min="0.01" max="1" step="0.01" value="0.05">
                </div>
                <button class="tool-button" id="reset-view" data-tooltip="Reset View">Reset</button>
                <button class="tool-button" id="toggle-material" data-tooltip="Show/Hide Material">Material</button>
                <button class="tool-button" id="export-btn" data-tooltip="Export as STL">Export</button>
            </div>
            <div class="control-icons">
                <div id="ctrl-fastrewind" class="icon">
                    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="fast-backward" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-fast-backward fa-w-16" style="transform-origin:0.5em 0.5em;">
                        <g transform="translate(256 256)" class="">
                            <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                <path fill="currentColor" d="M0 436V76c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v151.9L235.5 71.4C256.1 54.3 288 68.6 288 96v131.9L459.5 71.4C480.1 54.3 512 68.6 512 96v320c0 27.4-31.9 41.7-52.5 24.6L288 285.3V416c0 27.4-31.9 41.7-52.5 24.6L64 285.3V436c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12z" transform="translate(-256 -256)" class=""></path>
                            </g>
                        </g>
                    </svg>
                </div>
                <div id="ctrl-rewind" class="icon">
                    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="step-backward" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-step-backward fa-w-14" style="transform-origin:0.4375em 0.5em;">
                        <g transform="translate(224 256)" class="">
                            <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                <path fill="currentColor" d="M64 468V44c0-6.6 5.4-12 12-12h48c6.6 0 12 5.4 12 12v176.4l195.5-181C352.1 22.3 384 36.6 384 64v384c0 27.4-31.9 41.7-52.5 24.6L136 292.7V468c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12z" transform="translate(-224 -256)" class=""></path>
                            </g>
                        </g>
                    </svg>
                </div>
                <div id="ctrl-play-reverse" class="icon">
                    <div style="display:;">
                        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="play-btn-reverse" class="svg-inline--fa fa-play fa-w-14 fa-fw" style="transform-origin:0.4375em 0.5em;">
                            <g transform="translate(224 256)" class="">
                                <g transform="translate(0, 0)  scale(-1.125, 1.125)  rotate(0 0 0)" class="">
                                    <path fill="currentColor" d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z" transform="translate(-224 -256)" class=""></path>
                                </g>
                            </g>
                        </svg>
                    </div>
                    <div style="display:none;">
                        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pause" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="pause-btn-reverse" class="svg-inline--fa fa-pause fa-w-14 fa-fw" style="transform-origin:0.4375em 0.5em;">
                            <g transform="translate(224 256)" class="">
                                <g transform="translate(0, 0)  scale(-1.125, 1.125)  rotate(0 0 0)" class="">
                                    <path fill="currentColor" d="M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z" transform="translate(-224 -256)" class=""></path>
                                </g>
                            </g>
                        </svg>
                    </div>
                </div>
                <div id="ctrl-stop" class="icon">
                    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="stop" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-stop fa-w-14 fa-fw" style="transform-origin:0.4375em 0.5em;">
                        <g transform="translate(224 256)" class="">
                            <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                <path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z" transform="translate(-224 -256)" class=""></path>
                            </g>
                        </g>
                    </svg>
                </div>
                <div id="ctrl-play" class="icon">
                    <div style="display:;">
                        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="play-btn" class="svg-inline--fa fa-play fa-w-14 fa-fw" style="transform-origin:0.4375em 0.5em;">
                            <g transform="translate(224 256)" class="">
                                <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                    <path fill="currentColor" d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z" transform="translate(-224 -256)" class=""></path>
                                </g>
                            </g>
                        </svg>
                    </div>
                    <div style="display:none;">
                        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="pause" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" id="pause-btn" class="svg-inline--fa fa-pause fa-w-14 fa-fw" style="transform-origin:0.4375em 0.5em;">
                            <g transform="translate(224 256)" class="">
                                <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                    <path fill="currentColor" d="M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z" transform="translate(-224 -256)" class=""></path>
                                </g>
                            </g>
                        </svg>
                    </div>
                </div>
                <div id="ctrl-fwd" class="icon">
                    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="step-forward" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-step-forward fa-w-14" style="transform-origin:0.4375em 0.5em;">
                        <g transform="translate(224 256)" class="">
                            <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                <path fill="currentColor" d="M384 44v424c0 6.6-5.4 12-12 12h-48c-6.6 0-12-5.4-12-12V291.6l-195.5 181C95.9 489.7 64 475.4 64 448V64c0-27.4 31.9-41.7 52.5-24.6L312 219.3V44c0-6.6 5.4-12 12-12h48c6.6 0 12 5.4 12 12z" transform="translate(-224 -256)" class=""></path>
                            </g>
                        </g>
                    </svg>
                </div>
                <div id="ctrl-fastfwd" class="icon">
                    <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="fast-forward" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-fast-forward fa-w-16" style="transform-origin:0.5em 0.5em;">
                        <g transform="translate(256 256)" class="">
                            <g transform="translate(0, 0)  scale(1.125, 1.125)  rotate(0 0 0)" class="">
                                <path fill="currentColor" d="M512 76v360c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12V284.1L276.5 440.6c-20.6 17.2-52.5 2.8-52.5-24.6V284.1L52.5 440.6C31.9 457.8 0 443.4 0 416V96c0-27.4 31.9-41.7 52.5-24.6L224 226.8V96c0-27.4 31.9-41.7 52.5-24.6L448 226.8V76c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12z" transform="translate(-256 -256)" class=""></path>
                            </g>
                        </g>
                    </svg>
                </div>
            </div>
            <div id="viewcube">
                <div class="viewcube-controls">
                    <a id="vc-home"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="home" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" class="svg-inline--fa fa-home fa-w-18 fa-fw"><path fill="currentColor" d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z" class=""></path></svg></a>
                    <button class="viewcube-btn" id="vc-top">Top</button>
                    <button class="viewcube-btn" id="vc-front">Front</button>
                    <button class="viewcube-btn" id="vc-right">Right</button>
                </div>
                <span>Rhombicuboctahedron</span>
                <canvas id="viewcube-canvas" width="100" height="100" style="width: 100px; height: 100px;"></canvas>
            </div>
        </div>

        <div id="loading-overlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div>Loading...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/exporters/STLExporter.js"></script>

    <script>
        class McamParser {
            constructor(buffer) {
                this.buffer = buffer;
                this.dataView = new DataView(buffer);
                this.offset = 0;
                this.littleEndian = true;
                this.supportedVersions = [1, 2, 3];
            }

            parse() {
                console.log('MCAM Parser: File size:', this.buffer.byteLength);
                try {
                    this.checkFileSize();
                    const header = this.parseHeader();
                    console.log('MCAM Header:', header);
                    if (!this.supportedVersions.includes(header.version)) throw new Error(`Unsupported MCAM version ${header.version}`);
                    const geometry = this.parseGeometry(header.version);
                    console.log('MCAM Geometry: vertices=', geometry.vertices.length / 3, 'faces=', geometry.faces.length / 3);
                    const toolpaths = this.parseToolpaths(header.version);
                    console.log('MCAM Toolpaths:', toolpaths.length);
                    return { success: true, header, geometry, toolpaths };
                } catch (error) {
                    console.error('MCAM Binary Parsing Failed:', error.message);
                    const text = new TextDecoder().decode(this.buffer);
                    console.log('MCAM Fallback: First 100 chars:', text.slice(0, 100));
                    const gcodeParser = new GcodeParser(text);
                    const gcodeData = gcodeParser.parse();
                    if (gcodeData.success && gcodeData.toolpaths.length > 0) {
                        console.log('MCAM Fallback: Found valid G-code');
                        return { success: true, toolpaths: gcodeData.toolpaths, units: gcodeData.units };
                    }
                    return { success: false, error: `MCAM parsing failed: ${error.message}` };
                }
            }

            checkFileSize() { 
                if (this.buffer.byteLength < 16) throw new Error('File too small');
            }

            parseHeader() {
                const magic = this.readString(4);
                if (!['MCAM', 'MMC2'].includes(magic)) throw new Error(`Invalid header: ${magic}`);
                const version = this.readUint32();
                const fileSize = this.readUint32();
                if (fileSize > this.buffer.byteLength) throw new Error('File size mismatch');
                return { 
                    version, 
                    fileSize, 
                    creationDate: this.readUint64(), 
                    units: this.readByte() === 0 ? 'mm' : 'inch' 
                };
            }

            parseGeometry(version) {
                const vertexCount = this.readUint32();
                if (vertexCount > 1000000) throw new Error('Excessive vertex count');
                const vertices = new Float32Array(vertexCount * 3);
                for (let i = 0; i < vertexCount; i++) {
                    if (this.offset + 12 > this.buffer.byteLength) throw new Error('Unexpected end of file at vertices');
                    vertices[i * 3] = this.readFloat();
                    vertices[i * 3 + 1] = this.readFloat();
                    vertices[i * 3 + 2] = this.readFloat();
                }
                const faceCount = this.readUint32();
                if (faceCount > 2000000) throw new Error('Excessive face count');
                const faces = new Uint32Array(faceCount * 3);
                for (let i = 0; i < faceCount; i++) {
                    if (this.offset + 12 > this.buffer.byteLength) throw new Error('Unexpected end of file at faces');
                    faces[i * 3] = this.readUint32();
                    faces[i * 3 + 1] = this.readUint32();
                    faces[i * 3 + 2] = this.readUint32();
                }
                return { vertices, faces };
            }

            parseToolpaths(version) {
                if (this.offset + 2 > this.buffer.byteLength) throw new Error('Unexpected end of file at toolpath count');
                const pathCount = this.readUint16();
                const toolpaths = [];
                for (let i = 0; i < pathCount; i++) {
                    if (this.offset + 6 > this.buffer.byteLength) throw new Error('Unexpected end of file at toolpath header');
                    toolpaths.push({ toolNumber: this.readUint16(), points: this.readPathPoints() });
                }
                return toolpaths;
            }

            readPathPoints() {
                const pointCount = this.readUint32();
                const points = [];
                for (let i = 0; i < pointCount; i++) {
                    if (this.offset + 16 > this.buffer.byteLength) throw new Error('Unexpected end of file at toolpath points');
                    points.push({ 
                        x: this.readFloat(), 
                        y: this.readFloat(), 
                        z: this.readFloat(), 
                        feedRate: this.readFloat(),
                        a: 0
                    });
                }
                return points;
            }

            readUint32() { 
                if (this.offset + 4 > this.buffer.byteLength) throw new Error('Buffer overflow at Uint32');
                const v = this.dataView.getUint32(this.offset, this.littleEndian); 
                this.offset += 4; 
                return v; 
            }
            readUint16() { 
                if (this.offset + 2 > this.buffer.byteLength) throw new Error('Buffer overflow at Uint16');
                const v = this.dataView.getUint16(this.offset, this.littleEndian); 
                this.offset += 2; 
                return v; 
            }
            readFloat() { 
                if (this.offset + 4 > this.buffer.byteLength) throw new Error('Buffer overflow at Float');
                const v = this.dataView.getFloat32(this.offset, this.littleEndian); 
                this.offset += 4; 
                return v; 
            }
            readByte() { 
                if (this.offset + 1 > this.buffer.byteLength) throw new Error('Buffer overflow at Byte');
                const v = this.dataView.getUint8(this.offset); 
                this.offset += 1; 
                return v; 
            }
            readUint64() { 
                if (this.offset + 8 > this.buffer.byteLength) throw new Error('Buffer overflow at Uint64');
                const l = this.readUint32(); 
                const r = this.readUint32(); 
                return l + 2 ** 32 * r; 
            }
            readString(length) {
                if (this.offset + length > this.buffer.byteLength) throw new Error('Buffer overflow at String');
                let result = '';
                for (let i = 0; i < length; i++) {
                    const char = this.readByte();
                    if (char !== 0) result += String.fromCharCode(char);
                }
                return result;
            }
        }

        class GcodeParser {
            constructor(text) {
                this.text = text;
            }

            parse() {
                const lines = this.text.split('\n');
                const toolpaths = [];
                let currentTool = 0;
                let points = [];
                let lastPos = { x: 0, y: 0, z: 0, a: 0, feedRate: 0 };
                let units = 'mm';

                lines.forEach(line => {
                    line = line.trim().toUpperCase();
                    if (!line || line.startsWith(';') || line.startsWith('(')) return;
                    if (line.includes('G20')) units = 'inch';
                    if (line.includes('G21')) units = 'mm';
                    if (line.startsWith('T')) {
                        if (points.length) toolpaths.push({ toolNumber: currentTool, points });
                        points = [];
                        currentTool = parseInt(line.match(/T(\d+)/)?.[1]) || 0;
                    } else if (line.match(/G[0-1]/) || (line.includes('G254') || line.includes('G605'))) {
                        const coords = line.match(/[XYZA][-\d.]+|F[\d.]+/g) || [];
                        const point = { ...lastPos };
                        coords.forEach(c => {
                            const value = parseFloat(c.substring(1));
                            if (c[0] === 'X') point.x = value;
                            if (c[0] === 'Y') point.y = value;
                            if (c[0] === 'Z') point.z = value;
                            if (c[0] === 'A') point.a = value;
                            if (c[0] === 'F') point.feedRate = value;
                        });
                        points.push(point);
                        lastPos = { ...point };
                    }
                });

                if (points.length) toolpaths.push({ toolNumber: currentTool, points });
                return { success: true, toolpaths, units };
            }
        }

        class CNCViewer {
            constructor() {
                this.canvas2D = document.getElementById('canvas-2d');
                this.ctx2D = this.canvas2D.getContext('2d');
                this.scene = new THREE.Scene();
                this.camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer3D = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas-3d'), antialias: true });
                this.controls = new THREE.OrbitControls(this.camera3D, this.renderer3D.domElement);
                this.toolpaths = [];
                this.is2DView = false;
                this.showMaterial = false;
                this.materialMesh = null;
                this.animating = false;
                this.animationFrameId = null;
                this.currentToolNumber = 'N/A';
                this.viewcubeScene = new THREE.Scene();
                this.viewcubeCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                this.viewcubeRenderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('viewcube-canvas'), 
                    antialias: true 
                });
                this.init();
                this.initViewcube();
            }

            init() {
                this.resizeCanvas();
                this.ctx2D.strokeStyle = '#0000ff';
                this.ctx2D.lineWidth = 1;

                this.renderer3D.setSize(this.canvas2D.width, this.canvas2D.height);
                this.camera3D.position.set(50, 50, 50);
                this.camera3D.lookAt(0, 0, 0);
                this.controls.enableDamping = true;
                this.controls.target.set(0, 0, 0);
                this.scene.add(new THREE.AmbientLight(0x404040));
                const light = new THREE.DirectionalLight(0xffffff, 0.8);
                light.position.set(1, 1, 1);
                this.scene.add(light);

                const grid = new THREE.GridHelper(100, 100, 0x888888, 0x888888);
                grid.position.set(0, 0, -0.1);
                this.scene.add(grid);

                this.animate();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            initViewcube() {
                this.viewcubeRenderer.setSize(100, 100);
                this.viewcubeCamera.position.set(2, 2, 2);
                this.viewcubeCamera.lookAt(0, 0, 0);

                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: true });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                this.viewcubeScene.add(cube);

                const axesHelper = new THREE.AxesHelper(1.5);
                this.viewcubeScene.add(axesHelper);
            }

            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                this.canvas2D.width = container.clientWidth;
                this.canvas2D.height = container.clientHeight;
                this.renderer3D.setSize(container.clientWidth, container.clientHeight);
                this.camera3D.aspect = container.clientWidth / container.clientHeight;
                this.camera3D.updateProjectionMatrix();
            }

            loadToolpaths(toolpaths) {
                this.toolpaths = toolpaths;
                this.showMaterial = true;
                this.render2D();
                this.render3D();
                this.loadMaterial();
            }

            render2D() {
                this.ctx2D.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);
                const scale = Math.min(this.canvas2D.width, this.canvas2D.height) / 100;
                const offsetX = this.canvas2D.width / 2;
                const offsetY = this.canvas2D.height / 2;

                this.ctx2D.strokeStyle = '#888888';
                this.ctx2D.lineWidth = 0.5;
                for (let i = -50; i <= 50; i += 5) {
                    this.ctx2D.beginPath();
                    this.ctx2D.moveTo(i * scale + offsetX, -50 * scale + offsetY);
                    this.ctx2D.lineTo(i * scale + offsetX, 50 * scale + offsetY);
                    this.ctx2D.stroke();
                    this.ctx2D.beginPath();
                    this.ctx2D.moveTo(-50 * scale + offsetX, i * scale + offsetY);
                    this.ctx2D.lineTo(50 * scale + offsetX, i * scale + offsetY);
                    this.ctx2D.stroke();
                }

                this.ctx2D.strokeStyle = '#0000ff';
                this.ctx2D.lineWidth = 1;
                this.toolpaths.forEach(tp => {
                    this.ctx2D.beginPath();
                    tp.points.forEach((p, i) => {
                        const x = p.x * scale + offsetX;
                        const y = p.y * scale + offsetY;
                        if (i === 0) this.ctx2D.moveTo(x, y);
                        else this.ctx2D.lineTo(x, y);
                    });
                    this.ctx2D.stroke();
                });
            }

            render3D() {
                this.scene.children.filter(obj => obj.userData.isToolpath || obj === this.materialMesh).forEach(obj => this.scene.remove(obj));
                this.toolpaths.forEach(tp => {
                    const points = tp.points.map(p => {
                        const vec = new THREE.Vector3(p.x, p.y, p.z);
                        vec.applyAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(p.a || 0));
                        return vec;
                    });
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                    const line = new THREE.Line(geometry, material);
                    line.userData.isToolpath = true;
                    this.scene.add(line);
                });
            }

            loadMaterial() {
                if (this.materialMesh) this.scene.remove(this.materialMesh);
                if (!this.showMaterial || !this.toolpaths.length) return;

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                this.toolpaths.forEach(tp => {
                    tp.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        minZ = Math.min(minZ, p.z);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                        maxZ = Math.max(maxZ, p.z);
                    });
                });

                const width = Math.max(maxX - minX + 10, 50);
                const height = Math.max(maxY - minY + 10, 50);
                const depth = Math.max(maxZ - minZ + 10, 50);
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xaaaaaa, 
                    transparent: true, 
                    opacity: 0.7,
                    shininess: 30
                });
                this.materialMesh = new THREE.Mesh(geometry, material);
                this.materialMesh.position.set((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2);
                this.scene.add(this.materialMesh);
            }

            toggleView() {
                this.is2DView = !this.is2DView;
                this.canvas2D.style.display = this.is2DView ? 'block' : 'none';
                this.canvas3D.style.display = this.is2DView ? 'none' : 'block';
                if (this.is2DView) this.render2D();
            }

            toggleMaterial() {
                this.showMaterial = !this.showMaterial;
                if (this.materialMesh) this.materialMesh.visible = this.showMaterial;
                if (this.showMaterial && !this.materialMesh && this.toolpaths.length) this.loadMaterial();
            }

            resetView() {
                if (this.is2DView) {
                    this.render2D();
                } else {
                    this.camera3D.position.set(50, 50, 50);
                    this.controls.target.set(0, 0, 0);
                    this.controls.update();
                    this.viewcubeCamera.position.set(2, 2, 2);
                    this.viewcubeCamera.lookAt(0, 0, 0);
                }
            }

            setView(view) {
                if (this.is2DView) return;
                const distance = 75;
                switch (view) {
                    case 'top':
                        this.camera3D.position.set(0, distance, 0);
                        this.viewcubeCamera.position.set(0, 2, 0);
                        break;
                    case 'front':
                        this.camera3D.position.set(0, 0, distance);
                        this.viewcubeCamera.position.set(0, 0, 2);
                        break;
                    case 'right':
                        this.camera3D.position.set(distance, 0, 0);
                        this.viewcubeCamera.position.set(2, 0, 0);
                        break;
                    case 'home':
                        this.camera3D.position.set(50, 50, 50);
                        this.viewcubeCamera.position.set(2, 2, 2);
                        break;
                }
                this.controls.target.set(0, 0, 0);
                this.controls.update();
                this.viewcubeCamera.lookAt(0, 0, 0);
            }

            startSimulation(direction = 1) {
                if (!this.toolpaths.length) return;
                this.animating = true;
                if (!this.animationData) {
                    this.animationData = { 
                        currentPath: direction > 0 ? 0 : this.toolpaths.length - 1, 
                        currentPoint: direction > 0 ? 0 : this.toolpaths[direction > 0 ? 0 : this.toolpaths.length - 1].points.length - 1, 
                        speed: 0.05,
                        direction
                    };
                } else {
                    this.animationData.direction = direction;
                }
                document.getElementById(direction > 0 ? 'ctrl-play' : 'ctrl-play-reverse').classList.add('active');
                this.togglePlayPause(direction > 0 ? 'ctrl-play' : 'ctrl-play-reverse', true);
            }

            stopSimulation() {
                this.animating = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                document.getElementById('ctrl-play').classList.remove('active');
                document.getElementById('ctrl-play-reverse').classList.remove('active');
                this.togglePlayPause('ctrl-play', false);
                this.togglePlayPause('ctrl-play-reverse', false);
            }

            skipBackward(steps = 1) {
                if (!this.toolpaths.length || !this.animationData) return;
                this.animationData.currentPath = Math.max(0, this.animationData.currentPath - steps);
                this.animationData.currentPoint = 0;
                if (!this.animating) this.updateSimulation();
            }

            skipForward(steps = 1) {
                if (!this.toolpaths.length || !this.animationData) return;
                this.animationData.currentPath = Math.min(
                    this.toolpaths.length - 1,
                    this.animationData.currentPath + steps
                );
                this.animationData.currentPoint = 0;
                if (!this.animating) this.updateSimulation();
            }

            fastRewind() {
                this.skipBackward(5); // Skip 5 toolpaths back
            }

            fastForward() {
                this.skipForward(5); // Skip 5 toolpaths forward
            }

            setSpeed(speed) {
                if (this.animationData) {
                    this.animationData.speed = parseFloat(speed);
                }
            }

            exportToSTL() {
                if (!this.materialMesh) return;
                const exporter = new THREE.STLExporter();
                const stlString = exporter.parse(this.materialMesh);
                const blob = new Blob([stlString], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'cnc_model.stl';
                link.click();
            }

            togglePlayPause(buttonId, isPlaying) {
                const playBtn = document.getElementById(`${buttonId === 'ctrl-play' ? 'play-btn' : 'play-btn-reverse'}`);
                const pauseBtn = document.getElementById(`${buttonId === 'ctrl-play' ? 'pause-btn' : 'pause-btn-reverse'}`);
                playBtn.style.display = isPlaying ? 'none' : '';
                pauseBtn.style.display = isPlaying ? '' : 'none';
            }

            updateSimulation() {
                if (!this.animating || !this.animationData) return;
                const { currentPath, currentPoint, speed, direction } = this.animationData;
                
                if (currentPath >= this.toolpaths.length || currentPath < 0) {
                    this.stopSimulation();
                    return;
                }

                const path = this.toolpaths[currentPath];
                const pointIndex = Math.floor(currentPoint);
                
                if (pointIndex >= path.points.length || pointIndex < 0) {
                    this.animationData.currentPath += direction;
                    this.animationData.currentPoint = direction > 0 ? 0 : path.points.length - 1;
                    return;
                }

                const point = path.points[pointIndex];
                this.currentToolNumber = path.toolNumber;
                document.getElementById('current-tool').textContent = this.currentToolNumber;

                if (this.is2DView) {
                    this.render2D();
                    const scale = Math.min(this.canvas2D.width, this.canvas2D.height) / 100;
                    const offsetX = this.canvas2D.width / 2;
                    const offsetY = this.canvas2D.height / 2;
                    this.ctx2D.fillStyle = '#ff0000';
                    this.ctx2D.beginPath();
                    this.ctx2D.arc(point.x * scale + offsetX, point.y * scale + offsetY, 1, 0, 2 * Math.PI);
                    this.ctx2D.fill();
                } else {
                    const tool = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xff0000 })
                    );
                    tool.position.set(point.x, point.y, point.z);
                    tool.rotation.x = THREE.MathUtils.degToRad(point.a || 0) + Math.PI / 2;
                    tool.userData.isToolpath = true;
                    this.scene.add(tool);
                    setTimeout(() => this.scene.remove(tool), 100);
                }

                this.animationData.currentPoint += speed * direction;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(() => this.animate());
                this.updateSimulation();
                if (!this.is2DView) {
                    this.controls.update();
                    this.renderer3D.render(this.scene, this.camera3D);
                    const cameraDirection = new THREE.Vector3();
                    this.camera3D.getWorldDirection(cameraDirection);
                    this.viewcubeCamera.position.copy(cameraDirection).multiplyScalar(-2).add(new THREE.Vector3(0, 0, 0));
                    this.viewcubeCamera.lookAt(0, 0, 0);
                    this.viewcubeRenderer.render(this.viewcubeScene, this.viewcubeCamera);
                }
            }
        }

        function detectFileFormat(buffer, fileName) {
            const header = new Uint8Array(buffer.slice(0, 4));
            const headerStr = String.fromCharCode(...header);
            const ext = fileName.split('.').pop().toLowerCase();

            console.log('File header:', headerStr, 'Extension:', ext);
            if (headerStr === 'MCAM' || headerStr === 'MMC2') return 'MCAM';
            if (ext === 'gcode' || ext === 'nc' || ext === 'tap' || headerStr.startsWith('%') || new TextDecoder().decode(buffer).match(/G[0-1]/)) return 'GCODE';
            return 'UNKNOWN';
        }

        document.addEventListener('DOMContentLoaded', () => {
            const viewer = new CNCViewer();
            const uploadButton = document.getElementById('upload-button');
            const fileInput = document.getElementById('file-input');
            const gcodeInput = document.getElementById('gcode-input');
            const viewToggleBtn = document.getElementById('view-toggle');
            const ctrlFastRewind = document.getElementById('ctrl-fastrewind');
            const ctrlRewind = document.getElementById('ctrl-rewind');
            const ctrlPlayReverse = document.getElementById('ctrl-play-reverse');
            const ctrlStop = document.getElementById('ctrl-stop');
            const ctrlPlay = document.getElementById('ctrl-play');
            const ctrlFwd = document.getElementById('ctrl-fwd');
            const ctrlFastFwd = document.getElementById('ctrl-fastfwd');
            const speedSlider = document.getElementById('speed-slider');
            const resetViewBtn = document.getElementById('reset-view');
            const toggleMaterialBtn = document.getElementById('toggle-material');
            const exportBtn = document.getElementById('export-btn');
            const vcHomeBtn = document.getElementById('vc-home');
            const vcTopBtn = document.getElementById('vc-top');
            const vcFrontBtn = document.getElementById('vc-front');
            const vcRightBtn = document.getElementById('vc-right');
            const loadingOverlay = document.getElementById('loading-overlay');

            uploadButton.addEventListener('click', () => {
                console.log('Upload button clicked');
                fileInput.click();
            });

            function updateInfo(file, data) {
                document.getElementById('file-name').textContent = file ? file.name : 'None';
                document.getElementById('file-size').textContent = file ? `${(file.size / 1024).toFixed(2)} KB` : '0 KB';
                document.getElementById('toolpath-count').textContent = data.toolpaths.length;
                document.getElementById('units').textContent = data.units || data.header?.units || 'N/A';

                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                data.toolpaths.forEach(tp => {
                    tp.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        minZ = Math.min(minZ, p.z);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                        maxZ = Math.max(maxZ, p.z);
                    });
                });
                document.getElementById('bounds').textContent = `X: ${minX.toFixed(1)}-${maxX.toFixed(1)}, Y: ${minY.toFixed(1)}-${maxY.toFixed(1)}, Z: ${minZ.toFixed(1)}-${maxZ.toFixed(1)}`;
            }

            function loadFile(file) {
                loadingOverlay.style.display = 'flex';
                const reader = new FileReader();

                reader.onload = () => {
                    const buffer = reader.result;
                    const format = detectFileFormat(buffer, file.name);
                    console.log('Detected format:', format);

                    if (format === 'MCAM') {
                        const parser = new McamParser(buffer);
                        const data = parser.parse();
                        if (data.success) {
                            viewer.loadToolpaths(data.toolpaths);
                            updateInfo(file, data);
                            gcodeInput.value = data.geometry ? 'Binary MCAM file - toolpaths only (not editable)' : gcodeInput.value;
                        } else {
                            alert(`MCAM parsing failed: ${data.error}`);
                        }
                    } else if (format === 'GCODE') {
                        const text = new TextDecoder().decode(buffer);
                        gcodeInput.value = text;
                        const parser = new GcodeParser(text);
                        const data = parser.parse();
                        if (data.success) {
                            viewer.loadToolpaths(data.toolpaths);
                            updateInfo(file, data);
                        } else {
                            alert('G-code parsing failed');
                        }
                    } else {
                        alert(`Unsupported file format: ${format}`);
                    }
                    loadingOverlay.style.display = 'none';
                };

                reader.readAsArrayBuffer(file);
            }

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    console.log('File selected:', file.name);
                    loadFile(file);
                }
            });

            gcodeInput.addEventListener('change', () => {
                const parser = new GcodeParser(gcodeInput.value);
                const data = parser.parse();
                if (data.success) {
                    viewer.loadToolpaths(data.toolpaths);
                    updateInfo(null, data);
                }
            });

            viewToggleBtn.addEventListener('click', () => {
                viewer.toggleView();
                viewToggleBtn.classList.toggle('active');
            });

            ctrlFastRewind.addEventListener('click', () => {
                viewer.fastRewind();
            });

            ctrlRewind.addEventListener('click', () => {
                viewer.skipBackward();
            });

            ctrlPlayReverse.addEventListener('click', () => {
                if (viewer.animating && viewer.animationData.direction < 0) {
                    viewer.stopSimulation();
                } else {
                    viewer.stopSimulation();
                    viewer.startSimulation(-1);
                }
            });

            ctrlStop.addEventListener('click', () => {
                viewer.stopSimulation();
            });

            ctrlPlay.addEventListener('click', () => {
                if (viewer.animating && viewer.animationData.direction > 0) {
                    viewer.stopSimulation();
                } else {
                    viewer.stopSimulation();
                    viewer.startSimulation(1);
                }
            });

            ctrlFwd.addEventListener('click', () => {
                viewer.skipForward();
            });

            ctrlFastFwd.addEventListener('click', () => {
                viewer.fastForward();
            });

            speedSlider.addEventListener('input', (e) => {
                viewer.setSpeed(e.target.value);
            });

            resetViewBtn.addEventListener('click', () => viewer.resetView());

            toggleMaterialBtn.addEventListener('click', () => {
                viewer.toggleMaterial();
                toggleMaterialBtn.classList.toggle('active');
            });

            exportBtn.addEventListener('click', () => {
                viewer.exportToSTL();
            });

            vcHomeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                viewer.setView('home');
            });

            vcTopBtn.addEventListener('click', () => viewer.setView('top'));
            vcFrontBtn.addEventListener('click', () => viewer.setView('front'));
            vcRightBtn.addEventListener('click', () => viewer.setView('right'));

            gcodeInput.value = '';
        });
    </script>
</body>
</html>
