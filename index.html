<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced MCAM Viewer</title>
    <style>
        /* [Previous CSS styles remain exactly the same] */
    </style>
</head>
<body>
    <!-- [Previous HTML structure remains the same] -->

    <script>
        // ==============================================
        // Enhanced MCAM Parser with Debugging
        // ==============================================
        class McamParser {
            constructor(buffer) {
                this.buffer = buffer;
                this.dataView = new DataView(buffer);
                this.offset = 0;
                this.littleEndian = true;
                this.supportedVersions = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // Extended version support
                this.debug = true; // Enable debug output
            }

            parse() {
                try {
                    console.groupCollapsed('MCAM File Parsing');
                    this.checkFileSize();
                    this.checkEndianness();
                    const header = this.parseHeader();
                    
                    if (!this.supportedVersions.includes(header.version)) {
                        console.warn('Unsupported version:', header.version);
                        throw new Error(`Unsupported MCAM version ${header.version}. Supported: ${this.supportedVersions.join(', ')}`);
                    }

                    console.log('Header parsed successfully:', header);
                    const geometry = this.parseGeometry(header.version);
                    console.log('Geometry parsed:', {
                        vertices: geometry.vertices.length / 3,
                        faces: geometry.faces.length / 3
                    });

                    const toolpaths = this.parseToolpaths(header.version);
                    console.log('Toolpaths parsed:', toolpaths.length);
                    
                    return {
                        success: true,
                        header,
                        geometry,
                        toolpaths
                    };
                } catch (error) {
                    console.error('Parsing failed:', error);
                    return {
                        success: false,
                        error: error.message,
                        debug: this.getDebugInfo()
                    };
                } finally {
                    console.groupEnd();
                }
            }

            getDebugInfo() {
                return {
                    offset: this.offset,
                    bufferSize: this.buffer.byteLength,
                    remainingBytes: this.buffer.byteLength - this.offset,
                    hexPreview: this.getHexPreview(64)
                };
            }

            getHexPreview(bytes) {
                const hex = [];
                const end = Math.min(this.offset + bytes, this.buffer.byteLength);
                for (let i = this.offset; i < end; i++) {
                    hex.push(this.dataView.getUint8(i).toString(16).padStart(2, '0'));
                }
                return hex.join(' ');
            }

            // [Previous methods like checkFileSize, checkEndianness remain the same]

            parseHeader() {
                console.log('Parsing header at offset:', this.offset);
                const magic = this.readString(4);
                console.log('File magic:', magic);
                
                if (!['MCAM', 'MMC2', 'MCX7'].includes(magic)) {
                    throw new Error(`Invalid file header. Expected 'MCAM', 'MMC2' or 'MCX7', got '${magic}'`);
                }
                
                const version = this.readUint32();
                const fileSize = this.readUint32();
                const creationDate = this.readUint64();
                const units = this.readByte();
                
                console.log('Header values:', {
                    version,
                    fileSize,
                    creationDate,
                    units: units === 0 ? 'mm' : 'inch'
                });

                if (fileSize !== this.buffer.byteLength) {
                    console.warn(`File size mismatch. Header: ${fileSize}, Actual: ${this.buffer.byteLength}`);
                }
                
                return {
                    version,
                    fileSize,
                    creationDate: new Date(creationDate / 10000 - 11644473600000),
                    units: units === 0 ? 'mm' : 'inch',
                    magic
                };
            }

            parseGeometry(version) {
                try {
                    console.log('Parsing geometry at offset:', this.offset);
                    const vertexCount = this.readUint32();
                    console.log('Vertex count:', vertexCount);
                    
                    if (vertexCount > 5000000) {
                        throw new Error(`Excessive vertex count (${vertexCount}), possible file corruption`);
                    }
                    
                    const vertices = new Float32Array(vertexCount * 3);
                    for (let i = 0; i < vertexCount; i++) {
                        vertices[i * 3] = this.readFloat();
                        vertices[i * 3 + 1] = this.readFloat();
                        vertices[i * 3 + 2] = this.readFloat();
                    }

                    const faceCount = this.readUint32();
                    console.log('Face count:', faceCount);
                    
                    if (faceCount > 10000000) {
                        throw new Error(`Excessive face count (${faceCount}), possible file corruption`);
                    }
                    
                    const faces = new Uint32Array(faceCount * 3);
                    for (let i = 0; i < faceCount; i++) {
                        faces[i * 3] = this.readUint32();
                        faces[i * 3 + 1] = this.readUint32();
                        faces[i * 3 + 2] = this.readUint32();
                    }

                    return { vertices, faces };
                } catch (error) {
                    console.error('Geometry parsing failed at offset:', this.offset);
                    throw new Error(`Geometry parsing failed: ${error.message}`);
                }
            }

            // [Rest of the methods remain the same]
        }

        // ==============================================
        // Enhanced File Format Detection
        // ==============================================
        function detectFileFormat(buffer) {
            if (buffer.byteLength < 4) return {
                format: 'UNKNOWN',
                reason: 'File too small (minimum 4 bytes required)'
            };
            
            const view = new DataView(buffer);
            const magic = String.fromCharCode(
                view.getUint8(0),
                view.getUint8(1),
                view.getUint8(2),
                view.getUint8(3)
            );
            
            // Mastercam formats
            if (magic === 'MCAM') return { format: 'MCAM', version: view.getUint32(4, true) };
            if (magic === 'MMC2') return { format: 'MASTERCAM_V2', version: view.getUint32(4, true) };
            if (magic === 'MCX7') return { format: 'MASTERCAM_X7', version: view.getUint32(4, true) };
            
            // Check for ASCII content
            const textDecoder = new TextDecoder('utf-8', { fatal: false });
            const firstChunk = textDecoder.decode(buffer.slice(0, 100)).trim();
            
            if (firstChunk.startsWith('%')) return { format: 'GCODE' };
            if (firstChunk.startsWith('solid')) return { format: 'STL_ASCII' };
            if (firstChunk.includes('POSTPROCESSOR')) return { format: 'MASTERCAM_POST' };
            if (firstChunk.includes('<?xml')) return { format: 'XML' };
            
            // Check for binary STL
            if (buffer.byteLength > 84) {
                const faceCount = view.getUint32(80, true);
                const expectedSize = 84 + (faceCount * 50);
                if (buffer.byteLength === expectedSize) return { format: 'STL_BINARY' };
            }
            
            return {
                format: 'UNKNOWN',
                reason: 'No recognizable signature',
                hexPreview: Array.from(new Uint8Array(buffer.slice(0, 16)).map(b => b.toString(16).join(' ')
            };
        }

        // ==============================================
        // Enhanced Main Application with Debugging
        // ==============================================
        document.addEventListener('DOMContentLoaded', () => {
            // [Previous initialization code remains the same]

            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                showLoading(`Analyzing ${file.name}...`);
                console.groupCollapsed(`File Analysis: ${file.name}`);
                
                try {
                    const arrayBuffer = await readFileAsArrayBuffer(file);
                    
                    // Enhanced format detection
                    const formatInfo = detectFileFormat(arrayBuffer);
                    console.log('Format detection:', formatInfo);
                    
                    displayHexView(arrayBuffer);
                    updateFileInfo(file, formatInfo.format, null);
                    
                    if (formatInfo.format.includes('MCAM') || 
                        formatInfo.format.includes('MASTERCAM')) {
                        
                        const parser = new McamParser(arrayBuffer);
                        const result = parser.parse();
                        
                        if (result.success) {
                            console.log('Parsing successful:', result);
                            updateFileInfo(file, formatInfo.format, result);
                            viewer.loadGeometry(result.geometry);
                            
                            if (result.toolpaths?.length > 0) {
                                viewer.renderToolpaths(result.toolpaths);
                            }
                        } else {
                            console.error('Parsing failed:', result);
                            let errorMsg = result.error;
                            
                            // Add debug info to error message
                            if (result.debug) {
                                errorMsg += `\n\nDebug Info:\nOffset: ${result.debug.offset}\n`;
                                errorMsg += `Remaining: ${result.debug.remainingBytes} bytes\n`;
                                errorMsg += `Hex: ${result.debug.hexPreview}`;
                            }
                            
                            throw new Error(errorMsg);
                        }
                    } else {
                        throw new Error(formatInfo.reason || 
                            `Unsupported format: ${formatInfo.format}. Please use MCAM files.`);
                    }
                } catch (error) {
                    console.error('Processing error:', error);
                    showError(error.message);
                    updateFileInfo(file, `Error: ${error.message.split('\n')[0]}`, null);
                } finally {
                    hideLoading();
                    console.groupEnd();
                }
            });

            // [Rest of the event listeners remain the same]
        });
    </script>
</body>
</html>
